//-------------------------------------------------------------------
// Абстрактный класс Flying
//-------------------------------------------------------------------
#include <iostream>
#include "packcage.h" // Своя мини-библиотека
using namespace std;
//-------------------------------------------------------------------
/*
   0 1 2 3 4 5 6
 0 ┌──────────────► y (отсуп с левого края, left)
 1 │
 2 │
 3 │       # (3, 4)
 4 │
 5 │
 6 │   # (6, 2)
   │  
   ▼ x (отступ с верху, top)
*/
//-------------------------------------------------------------------
// Летающее (сущность)
class Flying
{
 public:
    int x, y;   // Позиция по осям
    int vx, vy; // Скорость по осям
    char tag;   // Вид метки на карте
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Конструктор без скорости (обнуляет скорость)
    Flying(size_t top,
           size_t left): x(top), y(left), vx(0), vy(0) {};
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Конструктор со скоростью (выставляет значения)
    Flying(size_t top,
           size_t left,
           size_t vtop,
           size_t vleft): x(top), y(left), vx(vtop), vy(vleft) {};
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Виртуальный деструктор для ликвидации проблем при удалении
    virtual ~Flying()
    {
        cout << "Deleting flying object!" << endl;
    };
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Отобразить на карте
    void display(DrawingMap &view)
    {
        view[x][y] = tag;
    }
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Обработать выход за границы карты
    void checkBounds(size_t width, size_t height)
    {
        if (x >= height) x = 0;
        else if (x < 0) x = height - 1;
        if (y >= width) y = 0;
        else if (y < 0) y = width - 1;
    }
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Виртуальный метод перемещения на представлении (карте)
    virtual void move(DrawingMap &view) = 0;
    // Его реализации НЕТ (!)
};
//-------------------------------------------------------------------
// Наследник Flying - Самолет, использует горючее для движения
class Plane: public Flying
{
 public:
    // Чисто для удобства редактирования кода
    static const char Plane_TAG = '>';
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    size_t f; // Горючее
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Сложносочиненный конструктор для самолета
    Plane(size_t top,
          size_t left,
          size_t vtop,
          size_t vleft,
          size_t fuel): f(fuel), Flying(top, left, vtop, vleft)
    {
        tag = Plane_TAG;
    };
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Деструктор - для уточнения порядка удаления
    ~Plane()
    {
        cout << "Deleting plane object: ";
    }
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Реализация метода move родителя
    virtual void move(DrawingMap &view)
    {
        view[x][y] = EMPTY_CELL; // На старом месте делаем пусто

        if (f > 0) // Если есть горючее
        {
            x += vx; // Двигаем по оси х (вертикальная)
            y += vy; // Двигаем по оси y (горизонтальная)
            --f;
        }
        
        checkBounds(view.w, view.h); // Обрабатываем выход за границы
        display(view);        // Ставим метку на карту на новом месте
    }
};
//-------------------------------------------------------------------
// Наследник Flying - НЛО, использует бесконечный источник топлива,
//                         но оставляет инверсионный след на карте
class UFO: public Flying
{
 public:
    // Константы для удобства
    static const char InvTrail = '*';
    static const char UFO_TAG = 'O';
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Сложносочиненный конструктор для самолета
    UFO(size_t top,
        size_t left,
        size_t vtop,
        size_t vleft): Flying(top, left, vtop, vleft)
    {
        tag = UFO_TAG;
    };
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Деструктор - для уточнения порядка удаления
    ~UFO()
    {
        cout << "Deleting UFO object: ";
    }
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Реализация метода move родителя
    virtual void move(DrawingMap &view)
    {
        view[x][y] = InvTrail; // Оставляем след на старом месте

        x += vx; // Двигаем по оси х (вертикальная)
        y += vy; // Двигаем по оси y (горизонтальная)
        
        checkBounds(view.w, view.h); // Обрабатываем выход за границы
        display(view);        // Ставим метку на карту на новом месте
    }
};
//-------------------------------------------------------------------
int main()
{
    // Создаем карту (представление) 5х5
    DrawingMap view(5, 5);

    // Отображаем карту
    view.draw();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // Создаем массив летающих объектов (N штук)
    const size_t N = 5;
    Flying *objects[N];

    // Каждый следующий самолет имеет больше топлива
    for (size_t i = 0; i < N-2; ++i)
        objects[i] = new Plane(0, i, 1, 0, i);

    // Просто НЛО
    for (size_t i = N-2; i < N; ++i)
        objects[i] = new UFO(0, i, 1, 0);

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Заметь, далее код остался прежним!
    // Это явление называется ПОЛИМОРФИЗМ -
    //     способность объекта использовать методы 
    //     производного класса с помощью виртуальных ф-ций
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // Помещаем метки на карту
    for (size_t i = 0; i < N; ++i)
        objects[i]->display(view);
    view.draw();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // Начинаем симуляцию 5-ти тиков
    for (size_t tick = 0; tick < 5; ++tick)
    {
        // Передвигаем каждый из N самолетов
        for (size_t i = 0; i < N; ++i)
            objects[i]->move(view);

        view.draw(); // Отрисовываем заново   
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // Не забываем удалить все N объектов
    for (size_t i = 0; i < N; ++i)
        delete objects[i];

    return 0;
}
//-------------------------------------------------------------------
//                                                       by SnipGhost
//-------------------------------------------------------------------